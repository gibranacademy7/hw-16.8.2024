# hw1a:
tuple_number = (99,);
print(tuple_number);

#hw1b:
tuple_numbers: tuple[int] = (11, 22, 33, 44, 55, 66, 77, 88, 99);
print(tuple_numbers);

# or:
tuple_numbers: tuple[int] = tuple(range(11, 100, 11));
print(tuple_numbers);


#hw1c:
def tuple_length(tup) -> len:
    return len(tup);
# or: tuple_length = lambda tup: len(tup);
example_tuple = (68, 57, 43, 798, 0, 55, 77, 790, 10);
length = tuple_length(example_tuple);
print(length);

#or:
tuple_length = lambda tup: len(tup);
example_tuple = (68, 57, 43, 798, 0, 55, 77, 790, 10);
length = tuple_length(example_tuple);
print(length);


#hw1d:
def concatenate_tuples(tup1, tup2):
    return tup1 + tup2
tuple1, tuple2 = ((1, 2, 3, 4, 5, 6), ('a', 'b', 'c', 'd', 'f'));
concatenate = concatenate_tuples(tuple1, tuple2);
print(concatenate);

#or:
concatenate_tuples = lambda tup1, tup2: tuple(tup1 + tup2);
tuple1, tuple2 = ((1, 2, 3, 4, 5, 6), ('a', 'b', 'c', 'd', 'f'));
concatenate = concatenate_tuples(tuple1, tuple2);
print(concatenate);


#hw1e:    find the common elements between two tuples:
common_items = lambda tup1, tup2: tuple(set(tup1) & set(tup2));
                                  # It converts each tuple into a set.
                                  # This operation removes duplicates (if any) and allows for set operations.
                                  # Then, it computes the intersection of the two sets.
                                  # The & operator finds the common elements between the two sets.
tuple1 = (3, 4, 5, 6, 'y', 'x', 99);
tuple2 = (1, 2, 3, 4, 99, 'x');
result = common_items(tuple1, tuple2);
print(result);


#hw1f:  find the elements that are different between two tuples:
different_elements = lambda tup1, tup2: tuple(set(tup1) ^ set(tup2));
                                        # computes the symmetric difference of the two sets.
                                        # The ^ operator finds the elements that are in either set but not in both.

tuple1 = (3, 4, 5, 6, 'y', 'x', 99);
tuple2 = (1, 2, 3, 4, 99, 'x');
result = different_elements(tuple1, tuple2);
print(result);


#hw1g: retrieve an element from a tuple based on a given index.
     # If the index is out of bounds, the function returns None
retrieve_element = lambda tup, index: tup[index] if 0 <= index < len(tup) else None;
                    # defines an anonymous (or inline) function that takes two arguments:
                    # tup (a tuple) and index (an integer representing the position in the tuple).
example_tuple = (10, 20, 30, 40, 50, 60, 70, 80);
print(retrieve_element(example_tuple, 2));
print(retrieve_element(example_tuple, 5));

#or:
def retrieve_element(tup, index):
    if 0 <=index < len(tup):
        return tup[index]
    else:
        return None

example_tuple = (10, 20, 30, 40, 50, 60, 70, 80);
print(retrieve_element(example_tuple, 2));
print(retrieve_element(example_tuple, 5));


#hw1h:
def reverse_tuple(tuple):
    return tuple[::-1]
only_tuple = (1970, 1980, 1990, 2000, 2010, 2020);
reversed_tuple = reverse_tuple(only_tuple);
print(reversed_tuple);

#or:
reverse_tuple = lambda tuple: tuple[::-1]
only_tuple = (1970, 1980, 1990, 2000, 2010, 2020);
reversed_tuple = reverse_tuple(only_tuple);
print(reversed_tuple);

#hw1i: כתוב פונקציה המקבלת סדורה ומספר, ומחזירה את כמות הפעמים שהמספר ומחלקיו השלמים מופיעים בסדורה
def divisors_in_tuple(tup, num):
    count = 0
    for item in tup:
        if num % item == 0:
            count += 1
    return count
example_tuple = (8, 4, 2, 5, 6, 16, 7, 3)
number = 16
result = divisors_in_tuple(example_tuple, number);
print(result);

#or:
divisors_in_tuple = lambda tup, num: sum(1 for item in tup if num % item == 0);
                                    # sum(...): The sum() function is used to add up all the 1s generated by the generator expression.
                                    # Each 1 represents an element in the tuple that is a divisor of num.
                                       # 1: For each element that satisfies the condition, 1 is added to the sum.
                                       # This effectively counts the number of divisors in the tuple.
example_tuple = (8, 4, 2, 5, 6, 16, 7, 3);
number = 16
result = divisors_in_tuple(example_tuple, number);
print(result);


# hw1j:
def repeat_tuple(tup, num):
    return tup * num
result = repeat_tuple((1, 2, 3, 4, '*'), 4);
print(result);
#or:
repeat_tuple = lambda tup, num: tup * num;
result = repeat_tuple((1, 2, 3, 4, '*'), 4);
print(result);


# hw1k:
def index_tuple(tup):
    return tuple((i, item) for i, item in enumerate(tup));  #  For each pair (i, item), it creates a tuple (i, item).
 # The enumerate function takes the input tuple tup and returns an iterator that produces pairs of index and item.
# For example, if tup is ('apple', 'banana') enumerate(tup) will produce (0, 'apple'), (1, 'banana') as it iterates.
fruit_tuple = ('Apple', 'Banana', 'Cherry', 'Cucumber', 'Tomato', 'Cabbage', 'Lettuce');
result = index_tuple(fruit_tuple);
print(result);

#or:
index_tuple = lambda tup: tuple((i, item) for i, item in enumerate(tup));

fruit_tuple = ('Apple', 'Banana', 'Cherry', 'Cucumber', 'Tomato', 'Cabbage', 'Lettuce')
result = index_tuple(fruit_tuple);
print(result);
#--------------------------------------------------------------------------------------

# hw1l:
def analyze_tuple(numbers):
    if not numbers:
        return {}
    # If the input tuple numbers is empty, the function returns an empty dictionary right away.
    # This prevents errors later when trying to compute statistics on an empty set.

    # Initialize Variables: are initialized to the first element of the tuple.
    # These variables will be updated as we iterate through the tuple.
    max_value = numbers[0];
    min_value = numbers[0];

    # חישוב סך הכל ומספר איברים עבור ממוצע
    total = 0       #total is initialized to 0 and will be used to calculate the sum of all elements.
    count = len(numbers);   #count stores the number of elements in the tuple using len(numbers).

    # מילון לספירת ההופעות של כל מספר
    occurrences = {};   #occurrences is an empty dictionary that will track how many times
                        # each number appears in the tuple.

    for number in numbers:
        if number > max_value:
            max_value = number;
        if number < min_value:
            min_value = number;
        # If the current number is greater than max_value, then max_value is updated.
        # If the current number is less than min_value, then min_value is updated.

        total += number
        # Each number is added to total.

        # ספירת הופעות
        if number in occurrences:
            occurrences[number] += 1
        else:
            occurrences[number] = 1
        # If the number is already in the occurrences dictionary, its count is incremented.
        # If the number is not in the dictionary, it is added with an initial count of 1.

    # חישוב ממוצע
    average = total / count

    sorted_asc = sorted(numbers);
    sorted_desc = sorted(numbers, reverse=True);
    # sorted_asc holds the numbers sorted in ascending order.
    # sorted_desc holds the numbers sorted in descending order.

    # החזרת התוצאה
    result = {
        'max': max_value,
        'min': min_value,
        'average': average,
        'count': count,
        'sorted_desc': sorted_desc,
        'sorted_asc': sorted_asc,
        'occurrences': occurrences
    }

    return result

numbers = (40, 30, 10, 50, 2, 3, 5, 5, 8, 10)
print(analyze_tuple(numbers))
#----------------------------

#hw1l-2nd version:
def analyze_tuple(numbers):
    if not numbers:
        return {}

    # פונקציות Lambda למקסימום, מינימום, וממוצע
    max_value = (lambda nums: max(nums))(numbers)
    min_value = (lambda nums: min(nums))(numbers)
    average = (lambda nums: sum(nums) / len(nums))(numbers)

    # מיון בעזרת Lambda
    sorted_asc = (lambda nums: sorted(nums))(numbers)
    sorted_desc = (lambda nums: sorted(nums, reverse=True))(numbers)

    # ספירת הופעות באמצעות Loop
    occurrences = {}
    for number in numbers:
        occurrences[number] = occurrences.get(number, 0) + 1
    # This loop iterates over each number in the tuple.
    # The get() method checks if the number already exists as a key in the occurrences dictionary.
    # If it does, it increments the count by 1; otherwise, it initializes the count at 1.
    # occurrences.get(number, 0):
    # ********* occurrences.get(number, 0) + 1 ***********
    # The get() method is a dictionary method that retrieves the value associated with a given key.
    # number: This is the key we're looking for in the dictionary.
    # 0: This is the default value to return if the number key is not already present in the dictionary.

    # החזרת התוצאה
    result = {
        'max': max_value,
        'min': min_value,
        'average': average,
        'count': len(numbers),
        'sorted_desc': sorted_desc,
        'sorted_asc': sorted_asc,
        'occurrences': occurrences
    }

    return result

numbers = (40, 30, 10, 50, 2, 3, 5, 5, 8, 10);
print(analyze_tuple(numbers));
#----------------------------------------------

#hw1l-3rd version:
from collections import Counter

def analyze_tuple(numbers):
    if not numbers:
        return {}

    # ניתוח סטטי
    result = {
        'max': max(numbers),
        'min': min(numbers),
        'average': sum(numbers) / len(numbers),
        'count': len(numbers),
        'sorted_desc': sorted(numbers, reverse=True),
        'sorted_asc': sorted(numbers)
    }

    # ספירת הופעות
    counter = Counter(numbers);
    result['occurrences'] = dict(counter);

    return result

numbers = (40, 30, 10, 50, 2, 3, 5, 5, 8, 10);
print(analyze_tuple(numbers));
#------------------------------------------------------------------------------------------

# hw1m:
def match_text_in_tuple(text, letters_tuple) -> str:
    # ממירה את המחרוזת לרשימה של אותיות
    text_letters = list(text)

    # בודק אם כל האותיות ב-tuple נמצאות במחרוזת
    for letter in letters_tuple:
        if letter not in text_letters:
            return None  # אם יש אות שלא קיימת, נחזיר None

    # אם כל האותיות קיימות, נחזיר את המחרוזת
    return text

text = "python"
letters_tuple = ('p')
result = match_text_in_tuple(text, letters_tuple);
print(result);
#---------------------------------------------------------------------------

# h1n:
def string_to_tuple(letters) -> tuple:
    return tuple(letters);

result = string_to_tuple("pycharm coding");
print(result);

#or:
string_to_tuple = lambda letters: tuple(letters);
result = string_to_tuple("pycharm coding");
print(result);
#------------------------------------------------

# hw1o:
def remove_number_from_tuple(tpl, num):
                            # (tpl): It represents the tuple that we want to modify by removing a specific number.
                            # (num): It represents the number that we want to remove from the tuple.
    return tuple(item for item in tpl if item != num);   # list comprehension: (generator expression) It checks whether each element x is not equal to the number num.
                                                # If x is not equal to num, it will be included in the new tuple.
                                                # If x equals num, it will be excluded.

original_tuple = (10, 8, 5, 5, 3, 2, 50, 10, 30, 40);
number_to_remove = 10
result_tuple = remove_number_from_tuple(original_tuple, number_to_remove);

print(result_tuple);
#-----------------------------------------------------------------------

# hw1p:
def remove_duplications(tup):
    distant_items = [];
    for item in tup:
        if item not in distant_items:
            distant_items.append(item);
    return tuple(distant_items);

tup = (1, 2, 2, 3, 4, 4, 5, 6, 7, 7);
result = remove_duplications(tup);
print(result);

# hw1q:
def locate_indices(tup, num):
    return [index for index, value in enumerate(tup) if value == num];

tup = (10, 8, 5, 5, 3, 2, 5, 10, 30, 40);
num = 5
indices = locate_indices(tup, num);
print(indices);

# hw1r:
# Collect names until 'done' is entered:
names = [];
while True:
    name = input("Enter a name (or 'done' to finish): ");
    if name.lower() == 'done':
        break
    names.append(name);

# Collect scores until -999 is entered:
scores = [];
while True:
    score = int(input("Enter a score (or -999 to finish): "));
    if score == -999:
        break
    scores.append(score);

# Create tuples of names and scores
result = tuple(zip(names, scores));

print(result);












